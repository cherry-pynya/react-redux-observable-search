{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable, Subject } from 'rxjs';\n\nvar StateObservable = function (_super) {\n  __extends(StateObservable, _super);\n\n  function StateObservable(input$, initialState) {\n    var _this = _super.call(this, function (subscriber) {\n      var subscription = _this.__notifier.subscribe(subscriber);\n\n      if (subscription && !subscription.closed) {\n        subscriber.next(_this.value);\n      }\n\n      return subscription;\n    }) || this;\n\n    _this.__notifier = new Subject();\n    _this.value = initialState;\n    input$.subscribe(function (value) {\n      // We only want to update state$ if it has actually changed since\n      // redux requires reducers use immutability patterns.\n      // This is basically what distinctUntilChanged() does but it's so simple\n      // we don't need to pull that code in\n      if (value !== _this.value) {\n        _this.value = value;\n\n        _this.__notifier.next(value);\n      }\n    });\n    return _this;\n  }\n\n  return StateObservable;\n}(Observable);\n\nexport { StateObservable };","map":{"version":3,"sources":["/Users/nikitacerepna/Desktop/netology/react/observable/react-redux-observable-search/node_modules/redux-observable/dist/esm/StateObservable.js"],"names":["__extends","Observable","Subject","StateObservable","_super","input$","initialState","_this","call","subscriber","subscription","__notifier","subscribe","closed","next","value"],"mappings":"AAAA,SAASA,SAAT,QAA0B,OAA1B;AACA,SAASC,UAAT,EAAqBC,OAArB,QAAoC,MAApC;;AACA,IAAIC,eAAe,GAAkB,UAAUC,MAAV,EAAkB;AACnDJ,EAAAA,SAAS,CAACG,eAAD,EAAkBC,MAAlB,CAAT;;AACA,WAASD,eAAT,CAAyBE,MAAzB,EAAiCC,YAAjC,EAA+C;AAC3C,QAAIC,KAAK,GAAGH,MAAM,CAACI,IAAP,CAAY,IAAZ,EAAkB,UAAUC,UAAV,EAAsB;AAChD,UAAIC,YAAY,GAAGH,KAAK,CAACI,UAAN,CAAiBC,SAAjB,CAA2BH,UAA3B,CAAnB;;AACA,UAAIC,YAAY,IAAI,CAACA,YAAY,CAACG,MAAlC,EAA0C;AACtCJ,QAAAA,UAAU,CAACK,IAAX,CAAgBP,KAAK,CAACQ,KAAtB;AACH;;AACD,aAAOL,YAAP;AACH,KANW,KAMN,IANN;;AAOAH,IAAAA,KAAK,CAACI,UAAN,GAAmB,IAAIT,OAAJ,EAAnB;AACAK,IAAAA,KAAK,CAACQ,KAAN,GAAcT,YAAd;AACAD,IAAAA,MAAM,CAACO,SAAP,CAAiB,UAAUG,KAAV,EAAiB;AAC9B;AACA;AACA;AACA;AACA,UAAIA,KAAK,KAAKR,KAAK,CAACQ,KAApB,EAA2B;AACvBR,QAAAA,KAAK,CAACQ,KAAN,GAAcA,KAAd;;AACAR,QAAAA,KAAK,CAACI,UAAN,CAAiBG,IAAjB,CAAsBC,KAAtB;AACH;AACJ,KATD;AAUA,WAAOR,KAAP;AACH;;AACD,SAAOJ,eAAP;AACH,CAzBoC,CAyBnCF,UAzBmC,CAArC;;AA0BA,SAASE,eAAT","sourcesContent":["import { __extends } from \"tslib\";\nimport { Observable, Subject } from 'rxjs';\nvar StateObservable = /** @class */ (function (_super) {\n    __extends(StateObservable, _super);\n    function StateObservable(input$, initialState) {\n        var _this = _super.call(this, function (subscriber) {\n            var subscription = _this.__notifier.subscribe(subscriber);\n            if (subscription && !subscription.closed) {\n                subscriber.next(_this.value);\n            }\n            return subscription;\n        }) || this;\n        _this.__notifier = new Subject();\n        _this.value = initialState;\n        input$.subscribe(function (value) {\n            // We only want to update state$ if it has actually changed since\n            // redux requires reducers use immutability patterns.\n            // This is basically what distinctUntilChanged() does but it's so simple\n            // we don't need to pull that code in\n            if (value !== _this.value) {\n                _this.value = value;\n                _this.__notifier.next(value);\n            }\n        });\n        return _this;\n    }\n    return StateObservable;\n}(Observable));\nexport { StateObservable };\n"]},"metadata":{},"sourceType":"module"}