{"ast":null,"code":"import { Subject, from, queueScheduler } from 'rxjs';\nimport { map, mergeMap, observeOn, subscribeOn } from 'rxjs/operators';\nimport { StateObservable } from './StateObservable';\nimport { warn } from './utils/console';\nexport function createEpicMiddleware(options) {\n  if (options === void 0) {\n    options = {};\n  } // This isn't great. RxJS doesn't publicly export the constructor for\n  // QueueScheduler nor QueueAction, so we reach in. We need to do this because\n  // we don't want our internal queuing mechanism to be on the same queue as any\n  // other RxJS code outside of redux-observable internals.\n\n\n  var QueueScheduler = queueScheduler.constructor;\n  var uniqueQueueScheduler = new QueueScheduler(queueScheduler.schedulerActionCtor);\n\n  if (process.env.NODE_ENV !== 'production' && typeof options === 'function') {\n    throw new TypeError('Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\n\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware');\n  }\n\n  var epic$ = new Subject();\n  var store;\n\n  var epicMiddleware = function (_store) {\n    if (process.env.NODE_ENV !== 'production' && store) {\n      // https://github.com/redux-observable/redux-observable/issues/389\n      warn('this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\n\\nLearn more: https://goo.gl/2GQ7Da');\n    }\n\n    store = _store;\n    var actionSubject$ = new Subject();\n    var stateSubject$ = new Subject();\n    var action$ = actionSubject$.asObservable().pipe(observeOn(uniqueQueueScheduler));\n    var state$ = new StateObservable(stateSubject$.pipe(observeOn(uniqueQueueScheduler)), store.getState());\n    var result$ = epic$.pipe(map(function (epic) {\n      var output$ = epic(action$, state$, options.dependencies);\n\n      if (!output$) {\n        throw new TypeError(\"Your root Epic \\\"\" + (epic.name || '<anonymous>') + \"\\\" does not return a stream. Double check you're not missing a return statement!\");\n      }\n\n      return output$;\n    }), mergeMap(function (output$) {\n      return from(output$).pipe(subscribeOn(uniqueQueueScheduler), observeOn(uniqueQueueScheduler));\n    }));\n    result$.subscribe(store.dispatch);\n    return function (next) {\n      return function (action) {\n        // Downstream middleware gets the action first,\n        // which includes their reducers, so state is\n        // updated before epics receive the action\n        var result = next(action); // It's important to update the state$ before we emit\n        // the action because otherwise it would be stale\n\n        stateSubject$.next(store.getState());\n        actionSubject$.next(action);\n        return result;\n      };\n    };\n  };\n\n  epicMiddleware.run = function (rootEpic) {\n    if (process.env.NODE_ENV !== 'production' && !store) {\n      warn('epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.');\n    }\n\n    epic$.next(rootEpic);\n  };\n\n  return epicMiddleware;\n}","map":{"version":3,"sources":["/Users/nikitacerepna/Desktop/netology/react/observable/react-redux-observable-search/node_modules/redux-observable/dist/esm/createEpicMiddleware.js"],"names":["Subject","from","queueScheduler","map","mergeMap","observeOn","subscribeOn","StateObservable","warn","createEpicMiddleware","options","QueueScheduler","constructor","uniqueQueueScheduler","schedulerActionCtor","process","env","NODE_ENV","TypeError","epic$","store","epicMiddleware","_store","actionSubject$","stateSubject$","action$","asObservable","pipe","state$","getState","result$","epic","output$","dependencies","name","subscribe","dispatch","next","action","result","run","rootEpic"],"mappings":"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","sourcesContent":["import { Subject, from, queueScheduler } from 'rxjs';\nimport { map, mergeMap, observeOn, subscribeOn } from 'rxjs/operators';\nimport { StateObservable } from './StateObservable';\nimport { warn } from './utils/console';\nexport function createEpicMiddleware(options) {\n    if (options === void 0) { options = {}; }\n    // This isn't great. RxJS doesn't publicly export the constructor for\n    // QueueScheduler nor QueueAction, so we reach in. We need to do this because\n    // we don't want our internal queuing mechanism to be on the same queue as any\n    // other RxJS code outside of redux-observable internals.\n    var QueueScheduler = queueScheduler.constructor;\n    var uniqueQueueScheduler = new QueueScheduler(queueScheduler.schedulerActionCtor);\n    if (process.env.NODE_ENV !== 'production' && typeof options === 'function') {\n        throw new TypeError('Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\n\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware');\n    }\n    var epic$ = new Subject();\n    var store;\n    var epicMiddleware = function (_store) {\n        if (process.env.NODE_ENV !== 'production' && store) {\n            // https://github.com/redux-observable/redux-observable/issues/389\n            warn('this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\n\\nLearn more: https://goo.gl/2GQ7Da');\n        }\n        store = _store;\n        var actionSubject$ = new Subject();\n        var stateSubject$ = new Subject();\n        var action$ = actionSubject$\n            .asObservable()\n            .pipe(observeOn(uniqueQueueScheduler));\n        var state$ = new StateObservable(stateSubject$.pipe(observeOn(uniqueQueueScheduler)), store.getState());\n        var result$ = epic$.pipe(map(function (epic) {\n            var output$ = epic(action$, state$, options.dependencies);\n            if (!output$) {\n                throw new TypeError(\"Your root Epic \\\"\" + (epic.name ||\n                    '<anonymous>') + \"\\\" does not return a stream. Double check you're not missing a return statement!\");\n            }\n            return output$;\n        }), mergeMap(function (output$) {\n            return from(output$).pipe(subscribeOn(uniqueQueueScheduler), observeOn(uniqueQueueScheduler));\n        }));\n        result$.subscribe(store.dispatch);\n        return function (next) {\n            return function (action) {\n                // Downstream middleware gets the action first,\n                // which includes their reducers, so state is\n                // updated before epics receive the action\n                var result = next(action);\n                // It's important to update the state$ before we emit\n                // the action because otherwise it would be stale\n                stateSubject$.next(store.getState());\n                actionSubject$.next(action);\n                return result;\n            };\n        };\n    };\n    epicMiddleware.run = function (rootEpic) {\n        if (process.env.NODE_ENV !== 'production' && !store) {\n            warn('epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.');\n        }\n        epic$.next(rootEpic);\n    };\n    return epicMiddleware;\n}\n"]},"metadata":{},"sourceType":"module"}